import{_ as p,c as e,j as a,a as i,G as l,a4 as t,B as h,o as k}from"./chunks/framework.D6yW5bo-.js";const u=JSON.parse('{"title":"位运算","description":"","frontmatter":{},"headers":[],"relativePath":"C/bit-calc.md","filePath":"C/bit-calc.md","lastUpdated":1728748156000}'),r={name:"C/bit-calc.md"};function d(c,s,b,E,o,g){const n=h("ArticleMetadata");return k(),e("div",null,[s[0]||(s[0]=a("h1",{id:"位运算",tabindex:"-1"},[i("位运算 "),a("a",{class:"header-anchor",href:"#位运算","aria-label":'Permalink to "位运算"'},"​")],-1)),l(n),s[1]||(s[1]=a("h1",{id:"位运算与写入",tabindex:"-1"},[i("位运算与写入 "),a("a",{class:"header-anchor",href:"#位运算与写入","aria-label":'Permalink to "位运算与写入"'},"​")],-1)),l(n),s[2]||(s[2]=t(`<blockquote><p>C 大师 011, 055-063</p></blockquote><p>在嵌入式和算法中，位运算符非常常见。一般寄存器都是以 bit 为单位来操作的。因此，掌握位运算的方法，非常重要。至于位运算符什么原理，怎么用，看上面的视频。下面总结一下：</p><ul><li>读取位用「与」</li><li>位置 0 用「与」 <code>&amp;=</code> ，置 1 用「或」 <code>|=</code></li><li>位取反用「异或」 <code>^=</code></li><li>操作某个位用移位操作，例如操作 <code>bit3</code> : <code>(1U &lt;&lt; 3)</code></li></ul><p>下面举个例子：</p><div class="language-C vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdint.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 状态寄存器</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * bit[31:16] 保留</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * bit[15] TXNE(R)   发送为空</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * bit[14] BASY(RW)  是否被占用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * bit[8:0] DATA(RW) 数据</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> status_reg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TXNE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">U</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BASY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">U</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 14</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* ... 写入数据到发区 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 是否被占用置1 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    status_reg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BASY;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TXNE)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 等待直至发送完成为空 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* 是否被占用置0 */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ~</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(BASY);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>如果你看不懂，不知道是怎么读取写入的，说明还是不够熟练，继续练习。</p><p>从 x 位到 y 位一般表示成 <code>bit[y:x]</code> ，y 在 x 前面是因为低位在后面。而我们说从 x 到 y 一般是从低位到高位。而说从 x 到 y 个字节可以表示成 <code>byte[x:y]</code> 。</p><p>其实借助结构体位域也可以实现位操作，参照：<a href="/C/ComplexStruct#位域-bit-field">位域</a>。但是位域不具有可移植性。如果你的代码在不同平台与不同编译器下编译，那么位域的大小和地址不一定是固定的。</p><h1 id="取余与位运算" tabindex="-1">取余与位运算 <a class="header-anchor" href="#取余与位运算" aria-label="Permalink to &quot;取余与位运算&quot;">​</a></h1>`,9)),l(n),s[3]||(s[3]=a("p",null,[i("在编程中，我们常常会遇到取余数的运算。取余数就是指的一个数不能整除的情况下的余数，也叫取模，例如： "),a("code",null,"5 / 3 = 1 ... 2"),i(" ，5 除以 3 的余数是 2。但是，如果取余的数是 2 的倍数，那么编译器会自动优化为位运算。你可能会感到迷惑，位运算与取余又有什么关系呢？我们先用十进制来看看：")],-1)),s[4]||(s[4]=a("p",null,[i("随机给你一个数，例如 1546156，这个数的 10 的余数一眼看出来就是 6。如果求 100 的余数，我相信你也能看出来余数是 56。那这是什么原理呢？我们擅长做 10 进制运算，如果是 10 的倍数，那么我们只需要"),a("strong",null,"取后面几位数字"),i("就可以了。")],-1)),s[5]||(s[5]=a("p",null,[i("那么对于二进制数，如果求 "),a("code",null,"0x234SAF2D"),i(" 对于 "),a("code",null,"0xF"),i(" 的余数，计算机只需要取最后 16 位数字就可以。怎么取数字的？做与运算就可以了。CPU 内部有非常多的逻辑运算单元（也就是与、或、非门电路），相比与算数运算，逻辑运算的速度非常快。因此，对 2 的倍数的取余运算，编译器会直接优化为按位与运算。")],-1))])}const m=p(r,[["render",d]]);export{u as __pageData,m as default};
