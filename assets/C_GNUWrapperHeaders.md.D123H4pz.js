import{_ as c,C as a,c as r,o as t,j as o,G as p,aj as n,a as s}from"./chunks/framework.DXOjwy1i.js";const f=JSON.parse('{"title":"包装头文件","description":"","frontmatter":{},"headers":[],"relativePath":"C/GNUWrapperHeaders.md","filePath":"C/GNUWrapperHeaders.md","lastUpdated":1734190649000}'),l={name:"C/GNUWrapperHeaders.md"};function i(_,e,h,A,u,m){const d=a("ArticleMetadata");return t(),r("div",null,[e[0]||(e[0]=o("h1",{id:"包装头文件",tabindex:"-1"},[s("包装头文件 "),o("a",{class:"header-anchor",href:"#包装头文件","aria-label":'Permalink to "包装头文件"'},"​")],-1)),p(d),e[1]||(e[1]=n('<blockquote><p><a href="https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html" target="_blank" rel="noreferrer">Wrapper Headers (The C Preprocessor)</a></p></blockquote><p>如果你阅读过 GCC 头文件源码，应该还会发现 <code>#include_next</code> 这样一个指令。这个指令是来自 GNU 的扩展，VS 默认的 MSVC 不支持。那这个指令是干什么的呢？其实上面 GNU 的文档已经说的比较明白了。下面我只是简单的翻译一下。</p><p>假如你的项目中已经有一个头文件 <code>A.h</code> 了，但是 <code>A.h</code> 不能满足需求，我想修改 <code>A.h</code> 的内容。我没有权限直接修改或删除 <code>A.h</code> 。最主要的问题是还必须得用 <code>A.h</code> 这个文件名，而且还得用旧的 <code>A.h</code> 里的内容。那这怎么办呢？先不管其他的创建一个 <code>A.h</code> 再说。创建后怎么处理旧的 <code>A.h</code> ？有下面几个问题：</p><ul><li>在新的头文件中直接包含旧的 <code>A.h</code> ，即 <code>#include &quot;A.h&quot;</code> 。但这有个问题，头文件一般都会做编译保护，引入旧的 <code>A.h</code> 可能不会被编译；如果删除了编译保护，两个文件将会无限 <code>#include</code> 循环导致编译错误</li><li>在新的头文件中用绝对路径包含旧的 <code>A.h</code> ，这不会产生上面的问题，但是如果文件被移动，或者其他系统没有这个文件也不能编译</li></ul><p>在 ISO C 中无法解决这个问题，但是可以用 GNU 的扩展指令， <code>#include_next &quot;filename&quot;</code> 。意思是去包含目录里找下一个叫 <code>filename</code> 的文件。它跟 <code>#include</code> 很像，但是不同的一点是不会有上面所说的编译保护问题。</p><p>这样就相当于把就的 <code>A.h</code> 包装了一遍，因此叫做包装头文件。</p><p>虽然可以用这个方法修改一些只读头文件的内容，但是 GNU 并不推荐你这么做，这会造成很大的混乱。我现在引用的这个东西，是来自新的 <code>A.h</code> ？还是旧的 <code>A.h</code> 。除非你的别无它法的时候才能用这个指令。</p>',7))])}const C=c(l,[["render",i]]);export{f as __pageData,C as default};
