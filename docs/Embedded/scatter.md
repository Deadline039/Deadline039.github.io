# armlink与分散加载文件

> [Scatter-loading Features - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/f/using-scatter-files)
>
> [Scatter File Syntax - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/scatter-file-syntax?lang=en)
>
> [Keil MDK（ARM编译器）分散加载特性（下）：使用分散加载文件（.sct）控制 – 哈冬猪的小站 – 个人学习记录](https://hadongzhu.com/archives/260)

::: tip
AC6的armlink移植自AC5，所以下面的内容AC5/AC6通用
:::

## 简介

分散加载文件（scatter-loader file，文件后缀为sct）是ARM Compiler (AC5/AC6)所需要的链接控制文件。简单来说，这个文件描述了RAM/ROM的地址与大小，变量、代码放哪里，怎么放，这些事是链接器来干的。

简单的内存布局不需要手动编写sct文件，使用MDK, EIDE自带的RAM/ROM Layout足矣。只需要设置起始地址与大小（偏移量）就可以了。

![STM32F103RC的RAM/ROM布局](/Embedded/ram-rom-layout.png)

其实，在MDK, EIDE等IDE编译之前，会自动根据这个GUI里的设置生成一个sct文件供armlink使用，仔细观察编译目录就会发现sct文件。上面STM32F103RC的RAM/ROM Layout设置，EIDE生成的sct文件如下：

```
; ******************************************************************
; *** Scatter-Loading Description File generated by Embedded IDE ***
; ******************************************************************

LR_IROM1 0x08000000 0x00040000 {
	ER_IROM1 0x08000000 0x00040000 {
		*.o (RESET, +First) 
		*(InRoot$$Sections) 
		.ANY (+RO) 
		.ANY (+XO) 
	}
	RW_IRAM1 0x20000000 0x0000C000 {
		.ANY (+RW +ZI)
	}
}
```

但是，如果遇到一些复杂内存布局的MCU，或者需要用到外部ROM/RAM的程序，需要管理多块内存的时候，仅仅使用此GUI就显得捉襟见肘了。什么时候建议使用分散加载文件呢？下面是ARM官方的建议：

> [When to use scatter-loading - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/scatter-loading-features/the-scatter-loading-mechanism/when-to-use-scatter-loading?lang=en)

- 复杂的存储布局：代码和数据必须明确指定存储区域
- 多种存储类型：例如一个系统包含多种存储设备，如内部Flash、内部SRAM、高速SRAM、外部SDRAM、外部ROM等。这时候就需要sct文件去描述这些存储区域
- 地址映射的外设：例如FMC、QSPI等外设。通常扩展的SDRAM需要用到FMC，sct文件可以描述这些存储区域，并且可以很方便地访问
- 固定常量内容位置：如果一些代码内容不会变化，且在一个固定的地址，不需要重新擦写（Flash擦写也是有寿命的）即使周围的程序已经修改后重新编译，这部分固定位置的代码不会受影响。这对一些GUI程序非常有用，图片、字库这类资源通常非常大，但是又不会经常修改，每次改代码重新编译不仅下载费时间，芯片频繁擦写还会导致Flash寿命变短
- 指定堆栈位置：默认情况下，堆栈由链接器自动分配。可以手动指定堆栈的分配区域

以下应用场景我建议手动编写分散加载文件：

- 内存布局较为复杂，需要手动指定存储区域，例如STM32H7
- 应用程序需要用到Bootloader，一部分ROM存储Bootloader代码；另一部分ROM存储应用代码
- 需要用到外部Flash外扩ROM空间，例如使用QSPI Flash存储数据或者代码

## 加载域与运行域

::: warning
这里以及后面所说的变量都指的是静态变量，函数的局部变量、malloc分配的动态内存都不属于此部分变量。
:::

简单来说，一个程序要运行，需要ROM存储代码，运行时需要将数据从ROM加载到RAM来执行。那么，ROM就可以理解为加载域，负责将数据和指令**加载**到RAM中执行；RAM就可以理解为执行域，负责存储数据执行代码。下图是一个简单的内存布局图：

![STM32F103RC内存布局](/Embedded/f1-sct-view.svg)

左侧是加载域视图；右侧是运行域视图。加载域中包含RO Section和RW Section，存储在ROM中；在上电后，先将加载域RW Section的数据复制或者解压到运行域SRAM中的RW Section中，SRAM中的ZI Section进行零填充，RO Section仍然在ROM区域，等待CPU调用。一个加载域可以包含多个运行域。

在C程序中，程序段可以分为 .bbs, .text段等（[内存布局](/C/PtrMemory#内存布局)），在armlink中定义的数据类型以及他们对应的程序段如下：

- XO (Execute Only): 只执行数据，就是Code，对应 .text，即代码段，通常存储在ROM中
- RO (Read Only) Data: 只读数据，对应 .rodata段，通常存储在ROM中，const修饰的静态变量
- RW (Read and Write) Data: 可读写数据，对应 .data段，存储在RAM中，*赋初始值的*静态变量
- ZI (Zero Initialized) Data: 初始零数据，对应 .bss段，存储在RAM中，静态变量区，与RW的区别在于ZI没有赋初始值，默认为0

RW的初始值需要存储在ROM中，上电需要加载到RAM中，给变量赋初值。所以镜像大小等于Code + RO Data + RW Data。这就是ARM Compiler每次编译完成输出的信息：

``` bash
# 编译工程 1 输出信息：
Program Size: Code=25340 RO-data=2272 RW-data=655520 ZI-data=33562800  

Total RO  Size (Code + RO Data)                27612 (  26.96kB)
Total RW  Size (RW Data + ZI Data)          34218320 (33416.33kB)
Total ROM Size (Code + RO Data + RW Data)      32804 (  32.04kB)

# 编译工程 2 输出信息：
Program Size: Code=18516 RO-data=1056 RW-data=80 ZI-data=8472  

Total RO  Size (Code + RO Data)                19572 (  19.11kB)
Total RW  Size (RW Data + ZI Data)              8552 (   8.35kB)
Total ROM Size (Code + RO Data + RW Data)      19652 (  19.19kB)
```

## armlink对RW data的压缩

> [Optimization with RW data compression - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/i/using-linker-optimizations/working-with-rw-data-compression)

当压缩后的RW-data + 解压缩程序大小<解压后的RW-data大小时，armlink会对RW-data压缩，在上电后解压到RAM中，例如上述工程1编译输出的大小就不匹配。所以实际镜像大小不完全等于Code + RO + RW。

可以使用`--datacompressor off`选项关闭压缩，关闭后编译工程1的信息如下：

```  bash
Program Size: Code=25276 RO-data=2272 RW-data=655520 ZI-data=33562800  

Total RO  Size (Code + RO Data)                27548 (  26.90kB)
Total RW  Size (RW Data + ZI Data)          34218320 (33416.33kB)
Total ROM Size (Code + RO Data + RW Data)     683068 ( 667.06kB)
```

可以发现ROM大小是对得上Code + RO + RW的，打开压缩可以减小镜像体积，上面打开压缩选项的情况下镜像大小仅为32.04 kB，不压缩大小为667.06 kB。这对于体积敏感的应用场景十分重要。

我们可以输入以下指令查看压缩器：

``` bash
➜  ~ armlink --datacompressor list
Product: Keil MDK Community (non-commercial free of charge)
Component: Arm Compiler for Embedded 6.24
Tool: armlink [xxxxxx]
To use a specific compressor pass the number of the compressor.

 Num  Compression algorithm
 =============================================================================
   0  Run-length encoding
   1  Run-length encoding, with LZ77 on small repeats
   2  Complex LZ77 compression
```

这三种压缩器的特点如下：

- 压缩器0在有大量零字节数据，很少非零字节数据的情况下表现较好
- 压缩器1在有很多重复的非零数据的情况下表现较好
- 压缩器2在数据包含很多重复值的情况下表现较好

当数据中包含很多零字节数据（>75%）时，链接器倾向使用压缩器0和1；当数据包含较少零字节数据（<10%）时，链接器会选择压缩器2。如果镜像没有明显的特征，链接器会使用所有压缩器压缩一遍，选择压缩体积最小的那个。

在编译时可以用`--datacompressor x`可以指定上述三种压缩器，`x`可以是`0-2`。目前不支持自己添加压缩器。

armlink会根据镜像代码自动选择解压器的代码类型。如果镜像只包含ARM code，解压器会使用ARM code；如果镜像包含Thumb code，解压器会使用Thumb code。

## 分散加载文件语法

::: warning
以下代码仅在Arm Compiler for Embedded 6.24测试通过，测试平台为 macOS Sequoia 15.5 (Apple M4)，未在其他版本的编译器、AC5下测试，可能有不兼容的语法。
:::

在搞清楚什么是加载域、运行域以及RO、ZI、RW这些名词的概念后，我们来看看分散加载文件的语法。以上面自动生成的STM32F103RC的分散加载文件为例，来分析一下分散加载文件的语法，以及如何编写分散加载文件。

```
LR_IROM1 0x08000000 0x00040000 {		; 加载域 LR_IROM1, 起始地址 0x08000000, 大小 0x0004000
	ER_IROM1 0x08000000 0x00040000 {	; 运行域 ER_IROM1, 起始地址 0x08000000, 大小 0x0004000
		*.o (RESET, +First) 			; 所有的 .o 文件, RESET放在最前面`优先(+First)`放这里
		*(InRoot$$Sections)				; 库文件也放这里
		.ANY (+RO)						; 所有`未指定`地址的 RO 数据放这里
		.ANY (+XO)						; 所有`未指定`地址的 XI(代码) 数据放这里
	}
	RW_IRAM1 0x20000000 0x0000C000 {	; 运行域 RW_IRAM1, 起始地址 0x20000000, 大小 0x0000C000
		.ANY (+RW +ZI)					; 所有`未指定`位置的 RW, ZI 数据放这里
	}
}
```

注释以分号开始。

### 定义加载域与运行域

一级大括号定义加载域，二级大括号定义运行域。加载域的大括号中只能写运行域定义，运行域的大括号中只能写输入节描述。不可以在加载域里写输入节描述，也不可以在运行域中定义运行域。

```
加载域 1 名称 起始地址 大小 属性 {
	运行域 1 名称 起始地址 大小 属性 {
		输入节描述
	}

	运行域 2 名称 起始地址 大小 属性 {
		输入节描述
	}
}

加载域 2 名称 起始地址 大小 属性 {
	运行域 3 名称 起始地址 大小 属性 {
		输入节描述
	}

	运行域 4 名称 起始地址 大小 属性 {
		输入节描述
	}
}
```

大小可以省略（省略后默认为 4 GB），属性也可以省略。名称不能重复，区域不能重叠，起始地址必须8字节对齐（也就是8的整数倍）。这里的大小单位均为字节。

### 加载域属性

> [Load region attributes - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/scatter-file-syntax/load-region-descriptions/load-region-attributes)。

### 运行域属性

> [Execution region attributes - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/scatter-file-syntax/execution-region-descriptions/execution-region-attributes)。

- `ABSOLUTE` 
- `ALIGN x`，x字节对齐
- `UNINIT`：即不要初始化运行域。这个属性在外部RAM中很重要，一般情况下，想要访问外部RAM需要初始化控制器，例如STM32外扩RAM通过FMC总线实现，使用前需要初始化FMC控制器，否则进入`HardFault`。默认情况下，定义的RAM块在进入`main`函数前会 Zero fill，也就是清零。这时候外部RAM还没有初始化，访问这块内存会直接进入`HardFault`

### 输入节描述 (Input Section Description)

> [Section-related symbols - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/accessing-and-managing-symbols-with-armlink/section-related-symbols?lang=en)
>
> [Input sections, output sections, regions, and program segments - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/image-structure-and-generation/the-structure-of-an-arm-elf-image/input-sections--output-sections--regions--and-program-segments)
>
> [Components of an input section description - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/m/scatter-file-syntax/input-section-descriptions/components-of-an-input-section-description)

编译器编译完源代码生成的对象文件中包含代码、各种数据。这些都会标记为不同的属性，即`RO, RW, XO, ZI`，它们将会作为链接器的输入。我们需要知道编译器是如何描述它们的，才可以把数据和代码放在指定位置。

输入节描述包含以下类型：

- 模块文件名，包括对象文件(.o)，库文件(.lib)，可以使用通配符
- 输入节名称或者属性，例如`READ_ONLY`或者`CODE`，可以使用通配符
- 符号名称，主要是ARM Compiler内建的组件

一个输入节描述构成如下：

![输入节描述](/Embedded/input-description.svg)

输入节描包括模块名称、输入节部分。

### 

## 示例

以STM32H743II为例，该芯片的RAM分为TCM、AXI、SRAM1-4，这几块内存区域速度不同、访问权限不同，且地址不连续。例如，STM32H743中仅MDMA能访问TCM内存，BDMA仅能访问SRAM4，还有Cache, MPU来掺合一脚，这时候就需要手动管理内存区域，设置不同DMA使用不同的内存区域。下表是STM32H743II的内存表以及DMA访问权限，同时我们添加一个外部SRAM，我们以此为例来编写一个sct文件。


| RAM区域  |  起始地址  | 空间大小（偏移量） | MDMA  |  DMA  | BDMA  |
| :------: | :--------: | :----------------: | :---: | :---: | :---: |
|   DTCM   | 0x20000000 |  128 KB (0x20000)  |   x   |       |       |
| AXI-SRAM | 0x24000000 |  512 KB (0x80000)  |   x   |   x   |       |
|  SRAM1   | 0x30000000 |  128 KB (0x20000)  |   x   |   x   |       |
|  SRAM2   | 0x30020000 |  128 KB (0x20000)  |   x   |   x   |       |
|  SRAM3   | 0x30040000 |   32 KB (0x8000)   |   x   |   x   |       |
|  SRAM4   | 0x38000000 |  64 KB (0x10000)   |   x   |   x   |   x   |
|  SDRAM   | 0xC0000000 | 32 MB (0x2000000)  |   x   |   x   |       |

