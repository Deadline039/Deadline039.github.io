# armlink与分散加载文件

> [ARM Compiler armlink User Guide Version 5.06 - Scatter-loading Features](https://developer.arm.com/documentation/dui0474/f/using-scatter-files)
>
> [ARM Compiler armlink User Guide Version 5.06 - Scatter File Syntax](https://developer.arm.com/documentation/dui0474/m/scatter-file-syntax?lang=en)
>
> [Keil MDK（ARM编译器）分散加载特性（下）：使用分散加载文件（.sct）控制 – 哈冬猪的小站 – 个人学习记录](https://hadongzhu.com/archives/260)

::: tip
AC6的armlink移植自AC5，所以下面的内容AC5/AC6通用
:::

## 简介

分散加载文件（scatter-loader file，文件后缀为sct）是ARM Compiler (AC5/AC6)所需要的链接控制文件。简单来说，这个文件描述了RAM/ROM的地址与大小，变量、代码放哪里，怎么放，这些事是链接器来干的。

简单的内存布局不需要手动编写sct文件，使用MDK, EIDE自带的RAM/ROM Layout足矣。只需要设置起始地址与大小（偏移量）就可以了。

![STM32F103RC的RAM/ROM布局](/Embedded/ram-rom-layout.png)

其实，在MDK, EIDE等IDE编译之前，会自动根据这个GUI里的设置生成一个sct文件供armlink使用，仔细观察编译目录就会发现sct文件。上面STM32F103RC的RAM/ROM Layout设置，EIDE生成的sct文件如下：

```
; ******************************************************************
; *** Scatter-Loading Description File generated by Embedded IDE ***
; ******************************************************************

LR_IROM1 0x08000000 0x00040000 {
	ER_IROM1 0x08000000 0x00040000 {
		*.o (RESET, +First) 
		*(InRoot$$Sections) 
		.ANY (+RO) 
		.ANY (+XO) 
	}
	RW_IRAM1 0x20000000 0x0000C000 {
		.ANY (+RW +ZI)
	}
}
```

但是，如果遇到一些复杂内存布局的MCU，或者需要用到外部ROM/RAM的程序，需要管理多块内存的时候，仅仅使用此GUI就显得捉襟见肘了。什么时候建议使用分散加载文件呢？下面是ARM官方的建议：

> [ARM Compiler armlink User Guide Version 5.06 - When to use scatter-loading](https://developer.arm.com/documentation/dui0474/m/scatter-loading-features/the-scatter-loading-mechanism/when-to-use-scatter-loading?lang=en)

- 复杂的存储布局：代码和数据必须明确指定存储区域
- 多种存储类型：例如一个系统包含多种存储设备，如内部Flash、内部SRAM、高速SRAM、外部SDRAM、外部ROM等。这时候就需要sct文件去描述这些存储区域
- 地址映射的外设：例如FMC、QSPI等外设。通常扩展的SDRAM需要用到FMC，sct文件可以描述这些存储区域，并且可以很方便地访问
- 固定常量内容位置：如果一些代码内容不会变化，且在一个固定的地址，不需要重新擦写（Flash擦写也是有寿命的）即使周围的程序已经修改后重新编译，这部分固定位置的代码不会受影响。这对一些GUI程序非常有用，图片、字库这类资源通常非常大，但是又不会经常修改，每次改代码重新编译不仅下载费时间，芯片频繁擦写还会导致Flash寿命变短
- 指定堆栈位置：默认情况下，堆栈由链接器自动分配。可以手动指定堆栈的分配区域

以下应用场景我建议手动编写分散加载文件：

- 内存布局较为复杂，需要手动指定存储区域，例如STM32H7
- 应用程序需要用到Bootloader，一部分ROM存储Bootloader代码；另一部分ROM存储应用代码
- 需要用到外部Flash外扩ROM空间，例如使用QSPI Flash存储数据或者代码

## 加载域与运行域

::: warning
这里以及后面所说的变量都指的是静态变量，函数的局部变量、malloc分配的动态内存都不属于此部分变量。
:::

简单来说，一个程序要运行，需要ROM存储代码，运行时需要将数据从ROM加载到RAM来执行。那么，ROM就可以理解为加载域，负责将数据和指令**加载**到RAM中执行；RAM就可以理解为执行域，负责存储数据执行代码。下图是一个简单的内存布局图：

![STM32F103RC内存布局](/Embedded/f1-sct-view.svg)

左侧是加载域视图；右侧是运行域视图。加载域中包含RO Section和RW Section，存储在ROM中；在上电后，先将加载域RW Section的数据复制或者解压到运行域SRAM中的RW Section中，SRAM中的ZI Section进行零填充，RO Section仍然在ROM区域，等待CPU调用。一个加载域可以包含多个运行域。

在C程序中，程序段可以分为 .bbs, .text段等（[内存布局](/C/PtrMemory#内存布局)），在armlink中定义的数据类型以及他们对应的程序段如下：

- Code: 代码数据，对应 .text，也就是代码段，通常存储在ROM中
- RO (Read Only) Data: 只读数据，对应 .rodata段，通常存储在ROM中，const修饰的静态变量
- RW (Read and Write) Data: 可读写数据，对应 .data段，存储在RAM中，*赋初始值的*静态变量
- ZI (Zero Initialized) Data: 初始零数据，对应 .bss段，存储在RAM中，静态变量区，与RW的区别在于ZI没有赋初始值，默认为0

RW的初始值需要存储在ROM中，上电需要加载到RAM中，给变量赋初值。所以镜像大小等于Code + RO Data + RW Data。这就是ARM Compiler每次编译完成输出的信息：

``` bash
# 编译工程 1 输出信息：
Program Size: Code=25340 RO-data=2272 RW-data=655520 ZI-data=33562800  

Total RO  Size (Code + RO Data)                27612 (  26.96kB)
Total RW  Size (RW Data + ZI Data)          34218320 (33416.33kB)
Total ROM Size (Code + RO Data + RW Data)      32804 (  32.04kB)

# 编译工程 2 输出信息：
Program Size: Code=18516 RO-data=1056 RW-data=80 ZI-data=8472  

Total RO  Size (Code + RO Data)                19572 (  19.11kB)
Total RW  Size (RW Data + ZI Data)              8552 (   8.35kB)
Total ROM Size (Code + RO Data + RW Data)      19652 (  19.19kB)
```

## armlink对RW data的压缩

> [Optimization with RW data compression - ARM Compiler armlink User Guide Version 5.06](https://developer.arm.com/documentation/dui0474/i/using-linker-optimizations/working-with-rw-data-compression)

当压缩后的RW-data + 解压缩程序大小<解压后的RW-data大小时，armlink会对RW-data压缩，在上电后解压到RAM中，例如上述工程1编译输出的大小就不匹配。所以实际镜像大小不完全等于Code + RO + RW。

可以使用`--datacompressor off`选项关闭压缩，关闭后编译工程1的信息如下：

```  bash
Program Size: Code=25276 RO-data=2272 RW-data=655520 ZI-data=33562800  

Total RO  Size (Code + RO Data)                27548 (  26.90kB)
Total RW  Size (RW Data + ZI Data)          34218320 (33416.33kB)
Total ROM Size (Code + RO Data + RW Data)     683068 ( 667.06kB)
```

可以发现ROM大小是对得上Code + RO + RW的，打开压缩可以减小镜像体积，上面打开压缩选项的情况下镜像大小仅为32.04 kB，不压缩大小为667.06 kB。这对于体积敏感的应用场景十分重要。

我们可以输入以下指令查看压缩器：

``` bash
➜  ~ armlink --datacompressor list
Product: Keil MDK Community (non-commercial free of charge)
Component: Arm Compiler for Embedded 6.24
Tool: armlink [xxxxxx]
To use a specific compressor pass the number of the compressor.

 Num  Compression algorithm
 =============================================================================
   0  Run-length encoding
   1  Run-length encoding, with LZ77 on small repeats
   2  Complex LZ77 compression
```

这三种压缩器的特点如下：

- 压缩器0在有大量零字节数据，很少非零字节数据的情况下表现较好
- 压缩器1在有很多重复的非零数据的情况下表现较好
- 压缩器2在数据包含很多重复值的情况下表现较好

当数据中包含很多零字节数据（>75%）时，链接器倾向使用压缩器0和1；当数据包含较少零字节数据（<10%）时，链接器会选择压缩器2。如果镜像没有明显的特征，链接器会使用所有压缩器压缩一遍，选择压缩体积最小的那个。

在编译时可以用`--datacompressor x`可以指定上述三种压缩器，`x`可以是`0-2`。目前不支持自己添加压缩器。

armlink会根据镜像代码自动选择解压器的代码类型。如果镜像只包含ARM code，解压器会使用ARM code；如果镜像包含Thumb code，解压器会使用Thumb code。

## 分散加载文件语法

## 示例

以STM32H743II为例，该芯片的RAM分为TCM、AXI、SRAM1-4，这几块内存区域速度不同、访问权限不同，且地址不连续。例如，STM32H743中仅MDMA能访问TCM内存，BDMA仅能访问SRAM4，还有Cache, MPU来掺合一脚，这时候就需要手动管理内存区域，设置不同DMA使用不同的内存区域。下表是STM32H743II的内存表以及DMA访问权限，同时我们添加一个外部SRAM，我们以此为例来编写一个sct文件。


| RAM区域  |  起始地址  | 空间大小（偏移量） | MDMA  |  DMA  | BDMA  |
| :------: | :--------: | :----------------: | :---: | :---: | :---: |
|   DTCM   | 0x20000000 |  128 KB (0x20000)  |   x   |       |       |
| AXI-SRAM | 0x24000000 |  512 KB (0x80000)  |   x   |   x   |       |
|  SRAM1   | 0x30000000 |  128 KB (0x20000)  |   x   |   x   |       |
|  SRAM2   | 0x30020000 |  128 KB (0x20000)  |   x   |   x   |       |
|  SRAM3   | 0x30040000 |   32 KB (0x8000)   |   x   |   x   |       |
|  SRAM4   | 0x38000000 |  64 KB (0x10000)   |   x   |   x   |   x   |
|  SDRAM   | 0xC0000000 | 32 MB (0x2000000)  |   x   |   x   |       |

