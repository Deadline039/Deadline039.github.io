
# 包装头文件

> [Wrapper Headers (The C Preprocessor)](https://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html)

如果你阅读过GCC头文件源码，应该还会发现`#include_next`这样一个指令。这个指令是来自GNU的扩展，VS默认的MSVC不支持。那这个指令是干什么的呢？其实上面GNU的文档已经说的比较明白了。下面我只是简单的翻译一下。

假如你的项目中已经有一个头文件`A.h`了，但是`A.h`不能满足需求，我想修改`A.h`的内容。我没有权限直接修改或删除`A.h`。最主要的问题是还必须得用`A.h`这个文件名，而且还得用旧的`A.h`里的内容。那这怎么办呢？先不管其他的创建一个`A.h`再说。创建后怎么处理旧的`A.h`？有下面几个问题：

- 在新的头文件中直接包含旧的`A.h`，即`#include "A.h"`。但这有个问题，头文件一般都会做编译保护，引入旧的`A.h`可能不会被编译；如果删除了编译保护，两个文件将会无限`#include`循环导致编译错误
- 在新的头文件中用绝对路径包含旧的`A.h`，这不会产生上面的问题，但是如果文件被移动，或者其他系统没有这个文件也不能编译

在ISO C中无法解决这个问题，但是可以用GNU的扩展指令，`#include_next "filename"`。意思是去包含目录里找下一个叫`filename`的文件。它跟`#include`很像，但是不同的一点是不会有上面所说的编译保护问题。

这样就相当于把就的`A.h`包装了一遍，因此叫做包装头文件。

虽然可以用这个方法修改一些只读头文件的内容，但是GNU并不推荐你这么做，这会造成很大的混乱。我现在引用的这个东西，是来自新的`A.h`？还是旧的`A.h`。除非你的别无它法的时候才能用这个指令。
